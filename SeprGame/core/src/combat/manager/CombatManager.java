package combat.manager;

import combat.actors.CombatEnemy;
import combat.actors.CombatPlayer;
import combat.items.Weapon;
import combat.ship.Room;
import combat.ship.Ship;
import javafx.util.Pair;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

@SuppressWarnings("FieldCanBeLocal")
public class CombatManager {
    private CombatPlayer player;
    private CombatEnemy enemy;
    private Boolean isPlayersTurn;

    public CombatManager(CombatPlayer player, CombatEnemy enemy) {
        this.player = player;
        this.enemy = enemy;
        this.isPlayersTurn = true;
//        combatLoop();
    }

    /**
     * Controls the whole process of combat from start to entering minigame.
     */
    public void combatLoop() {
        List<Pair<Room, Integer>> damageReport = new ArrayList<Pair<Room, Integer>>();
        List<Pair<Room, Weapon>> turnReport;

        while (true) {
            turnReport = player.takeTurn(damageReport);
            damageReport = calculateDamage(turnReport, player.getShip(), enemy.getShip());
            turnReport = enemy.takeTurn(damageReport);
            damageReport = calculateDamage(turnReport, enemy.getShip(), player.getShip());
        }


    }

    private List<Pair<Room, Integer>> calculateDamage(List<Pair<Room, Weapon>> turnReport, Ship shipFiring,
                                                      Ship shipFiredAt) {

        List<Pair<Room, Integer>> damageReport = new ArrayList<Pair<Room, Integer>>();

        for (Pair<Room, Weapon> shot : turnReport) {
            Room target = shot.getKey();
            Weapon weapon = shot.getValue();
            int damage;

            if (pickRandom() > (weapon.getAccuracy() * shipFiring.calculateAccuracy())) {
                damage = 0;
            } else if (pickRandom() > shipFiredAt.calculateEvadeChance()) {
                damage = 0;
            } else {
                damage = weapon.getBaseDamage();
                if (pickRandom() > (weapon.getCritChance() * shipFiring.calculateCritAccuracy())) {
                    damage *= 1.5;
                }
            }

            damageReport.add(new Pair<Room, Integer> (target, damage));
        }

        return damageReport;
    }

    public float pickRandom() {
        System.out.println("here");
        Random rand = new Random();
        return rand.nextFloat();
    }

    /**
     * Controls process of deciding what happened after a player took their turn.
     *
     * @param attackReport A report generated by CombatActor which tells the game which weapons were fired and at which
     *                     rooms. Eg: [[Helm, Cannon1],[Sails, Cannon3]]
     * @return damageReport - A report detailing which rooms were hit and for how much damage. See CombatActor >
     * takeTurn() for its use and more info.
     */
    List<Pair<Room, Integer>> applyTurn(List<Pair<Room, Weapon>> attackReport) {
        return null;
    }

    /**
     * Ends the fight and starts minigame.
     *
     * @return TODO Will end up returning outcome of combat to game manager
     * how this is done depends on implementation
     */
    private void endCombat() {
    }
}